// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'generate_key_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$NextStep {}

/// @nodoc
abstract class $NextStepCopyWith<$Res> {
  factory $NextStepCopyWith(NextStep value, $Res Function(NextStep) then) =
      _$NextStepCopyWithImpl<$Res, NextStep>;
}

/// @nodoc
class _$NextStepCopyWithImpl<$Res, $Val extends NextStep>
    implements $NextStepCopyWith<$Res> {
  _$NextStepCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NextStep
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$NextStepImplCopyWith<$Res> {
  factory _$$NextStepImplCopyWith(
          _$NextStepImpl value, $Res Function(_$NextStepImpl) then) =
      __$$NextStepImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NextStepImplCopyWithImpl<$Res>
    extends _$NextStepCopyWithImpl<$Res, _$NextStepImpl>
    implements _$$NextStepImplCopyWith<$Res> {
  __$$NextStepImplCopyWithImpl(
      _$NextStepImpl _value, $Res Function(_$NextStepImpl) _then)
      : super(_value, _then);

  /// Create a copy of NextStep
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$NextStepImpl with DiagnosticableTreeMixin implements _NextStep {
  const _$NextStepImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NextStep()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'NextStep'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NextStepImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _NextStep implements NextStep {
  const factory _NextStep() = _$NextStepImpl;
}

/// @nodoc
mixin _$PreviousStep {}

/// @nodoc
abstract class $PreviousStepCopyWith<$Res> {
  factory $PreviousStepCopyWith(
          PreviousStep value, $Res Function(PreviousStep) then) =
      _$PreviousStepCopyWithImpl<$Res, PreviousStep>;
}

/// @nodoc
class _$PreviousStepCopyWithImpl<$Res, $Val extends PreviousStep>
    implements $PreviousStepCopyWith<$Res> {
  _$PreviousStepCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PreviousStep
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$PreviousStepImplCopyWith<$Res> {
  factory _$$PreviousStepImplCopyWith(
          _$PreviousStepImpl value, $Res Function(_$PreviousStepImpl) then) =
      __$$PreviousStepImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PreviousStepImplCopyWithImpl<$Res>
    extends _$PreviousStepCopyWithImpl<$Res, _$PreviousStepImpl>
    implements _$$PreviousStepImplCopyWith<$Res> {
  __$$PreviousStepImplCopyWithImpl(
      _$PreviousStepImpl _value, $Res Function(_$PreviousStepImpl) _then)
      : super(_value, _then);

  /// Create a copy of PreviousStep
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PreviousStepImpl with DiagnosticableTreeMixin implements _PreviousStep {
  const _$PreviousStepImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PreviousStep()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'PreviousStep'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PreviousStepImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _PreviousStep implements PreviousStep {
  const factory _PreviousStep() = _$PreviousStepImpl;
}

/// @nodoc
mixin _$GenerateRSAKeyPair {}

/// @nodoc
abstract class $GenerateRSAKeyPairCopyWith<$Res> {
  factory $GenerateRSAKeyPairCopyWith(
          GenerateRSAKeyPair value, $Res Function(GenerateRSAKeyPair) then) =
      _$GenerateRSAKeyPairCopyWithImpl<$Res, GenerateRSAKeyPair>;
}

/// @nodoc
class _$GenerateRSAKeyPairCopyWithImpl<$Res, $Val extends GenerateRSAKeyPair>
    implements $GenerateRSAKeyPairCopyWith<$Res> {
  _$GenerateRSAKeyPairCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GenerateRSAKeyPair
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$GenerateRSAKeyPairImplCopyWith<$Res> {
  factory _$$GenerateRSAKeyPairImplCopyWith(_$GenerateRSAKeyPairImpl value,
          $Res Function(_$GenerateRSAKeyPairImpl) then) =
      __$$GenerateRSAKeyPairImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GenerateRSAKeyPairImplCopyWithImpl<$Res>
    extends _$GenerateRSAKeyPairCopyWithImpl<$Res, _$GenerateRSAKeyPairImpl>
    implements _$$GenerateRSAKeyPairImplCopyWith<$Res> {
  __$$GenerateRSAKeyPairImplCopyWithImpl(_$GenerateRSAKeyPairImpl _value,
      $Res Function(_$GenerateRSAKeyPairImpl) _then)
      : super(_value, _then);

  /// Create a copy of GenerateRSAKeyPair
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GenerateRSAKeyPairImpl
    with DiagnosticableTreeMixin
    implements _GenerateRSAKeyPair {
  const _$GenerateRSAKeyPairImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GenerateRSAKeyPair()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'GenerateRSAKeyPair'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GenerateRSAKeyPairImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _GenerateRSAKeyPair implements GenerateRSAKeyPair {
  const factory _GenerateRSAKeyPair() = _$GenerateRSAKeyPairImpl;
}

/// @nodoc
mixin _$GenerateAESSymmetricKey {}

/// @nodoc
abstract class $GenerateAESSymmetricKeyCopyWith<$Res> {
  factory $GenerateAESSymmetricKeyCopyWith(GenerateAESSymmetricKey value,
          $Res Function(GenerateAESSymmetricKey) then) =
      _$GenerateAESSymmetricKeyCopyWithImpl<$Res, GenerateAESSymmetricKey>;
}

/// @nodoc
class _$GenerateAESSymmetricKeyCopyWithImpl<$Res,
        $Val extends GenerateAESSymmetricKey>
    implements $GenerateAESSymmetricKeyCopyWith<$Res> {
  _$GenerateAESSymmetricKeyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GenerateAESSymmetricKey
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$GenerateAESSymmetricKeyImplCopyWith<$Res> {
  factory _$$GenerateAESSymmetricKeyImplCopyWith(
          _$GenerateAESSymmetricKeyImpl value,
          $Res Function(_$GenerateAESSymmetricKeyImpl) then) =
      __$$GenerateAESSymmetricKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GenerateAESSymmetricKeyImplCopyWithImpl<$Res>
    extends _$GenerateAESSymmetricKeyCopyWithImpl<$Res,
        _$GenerateAESSymmetricKeyImpl>
    implements _$$GenerateAESSymmetricKeyImplCopyWith<$Res> {
  __$$GenerateAESSymmetricKeyImplCopyWithImpl(
      _$GenerateAESSymmetricKeyImpl _value,
      $Res Function(_$GenerateAESSymmetricKeyImpl) _then)
      : super(_value, _then);

  /// Create a copy of GenerateAESSymmetricKey
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GenerateAESSymmetricKeyImpl
    with DiagnosticableTreeMixin
    implements _GenerateAESSymmetricKey {
  const _$GenerateAESSymmetricKeyImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GenerateAESSymmetricKey()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'GenerateAESSymmetricKey'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GenerateAESSymmetricKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _GenerateAESSymmetricKey implements GenerateAESSymmetricKey {
  const factory _GenerateAESSymmetricKey() = _$GenerateAESSymmetricKeyImpl;
}

/// @nodoc
mixin _$SelectTeacherPublicKeyFile {}

/// @nodoc
abstract class $SelectTeacherPublicKeyFileCopyWith<$Res> {
  factory $SelectTeacherPublicKeyFileCopyWith(SelectTeacherPublicKeyFile value,
          $Res Function(SelectTeacherPublicKeyFile) then) =
      _$SelectTeacherPublicKeyFileCopyWithImpl<$Res,
          SelectTeacherPublicKeyFile>;
}

/// @nodoc
class _$SelectTeacherPublicKeyFileCopyWithImpl<$Res,
        $Val extends SelectTeacherPublicKeyFile>
    implements $SelectTeacherPublicKeyFileCopyWith<$Res> {
  _$SelectTeacherPublicKeyFileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SelectTeacherPublicKeyFile
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SelectTeacherPublicKeyFileImplCopyWith<$Res> {
  factory _$$SelectTeacherPublicKeyFileImplCopyWith(
          _$SelectTeacherPublicKeyFileImpl value,
          $Res Function(_$SelectTeacherPublicKeyFileImpl) then) =
      __$$SelectTeacherPublicKeyFileImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectTeacherPublicKeyFileImplCopyWithImpl<$Res>
    extends _$SelectTeacherPublicKeyFileCopyWithImpl<$Res,
        _$SelectTeacherPublicKeyFileImpl>
    implements _$$SelectTeacherPublicKeyFileImplCopyWith<$Res> {
  __$$SelectTeacherPublicKeyFileImplCopyWithImpl(
      _$SelectTeacherPublicKeyFileImpl _value,
      $Res Function(_$SelectTeacherPublicKeyFileImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectTeacherPublicKeyFile
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SelectTeacherPublicKeyFileImpl
    with DiagnosticableTreeMixin
    implements _SelectTeacherPublicKeyFile {
  const _$SelectTeacherPublicKeyFileImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectTeacherPublicKeyFile()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'SelectTeacherPublicKeyFile'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectTeacherPublicKeyFileImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _SelectTeacherPublicKeyFile
    implements SelectTeacherPublicKeyFile {
  const factory _SelectTeacherPublicKeyFile() =
      _$SelectTeacherPublicKeyFileImpl;
}

/// @nodoc
mixin _$SelectFileToSend {}

/// @nodoc
abstract class $SelectFileToSendCopyWith<$Res> {
  factory $SelectFileToSendCopyWith(
          SelectFileToSend value, $Res Function(SelectFileToSend) then) =
      _$SelectFileToSendCopyWithImpl<$Res, SelectFileToSend>;
}

/// @nodoc
class _$SelectFileToSendCopyWithImpl<$Res, $Val extends SelectFileToSend>
    implements $SelectFileToSendCopyWith<$Res> {
  _$SelectFileToSendCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SelectFileToSend
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SelectFileToSendImplCopyWith<$Res> {
  factory _$$SelectFileToSendImplCopyWith(_$SelectFileToSendImpl value,
          $Res Function(_$SelectFileToSendImpl) then) =
      __$$SelectFileToSendImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectFileToSendImplCopyWithImpl<$Res>
    extends _$SelectFileToSendCopyWithImpl<$Res, _$SelectFileToSendImpl>
    implements _$$SelectFileToSendImplCopyWith<$Res> {
  __$$SelectFileToSendImplCopyWithImpl(_$SelectFileToSendImpl _value,
      $Res Function(_$SelectFileToSendImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectFileToSend
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SelectFileToSendImpl
    with DiagnosticableTreeMixin
    implements _SelectFileToSend {
  const _$SelectFileToSendImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectFileToSend()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'SelectFileToSend'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SelectFileToSendImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _SelectFileToSend implements SelectFileToSend {
  const factory _SelectFileToSend() = _$SelectFileToSendImpl;
}

/// @nodoc
mixin _$SignAndEncryptFile {}

/// @nodoc
abstract class $SignAndEncryptFileCopyWith<$Res> {
  factory $SignAndEncryptFileCopyWith(
          SignAndEncryptFile value, $Res Function(SignAndEncryptFile) then) =
      _$SignAndEncryptFileCopyWithImpl<$Res, SignAndEncryptFile>;
}

/// @nodoc
class _$SignAndEncryptFileCopyWithImpl<$Res, $Val extends SignAndEncryptFile>
    implements $SignAndEncryptFileCopyWith<$Res> {
  _$SignAndEncryptFileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SignAndEncryptFile
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SignAndEncryptFileImplCopyWith<$Res> {
  factory _$$SignAndEncryptFileImplCopyWith(_$SignAndEncryptFileImpl value,
          $Res Function(_$SignAndEncryptFileImpl) then) =
      __$$SignAndEncryptFileImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignAndEncryptFileImplCopyWithImpl<$Res>
    extends _$SignAndEncryptFileCopyWithImpl<$Res, _$SignAndEncryptFileImpl>
    implements _$$SignAndEncryptFileImplCopyWith<$Res> {
  __$$SignAndEncryptFileImplCopyWithImpl(_$SignAndEncryptFileImpl _value,
      $Res Function(_$SignAndEncryptFileImpl) _then)
      : super(_value, _then);

  /// Create a copy of SignAndEncryptFile
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SignAndEncryptFileImpl
    with DiagnosticableTreeMixin
    implements _SignAndEncryptFile {
  const _$SignAndEncryptFileImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SignAndEncryptFile()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'SignAndEncryptFile'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SignAndEncryptFileImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _SignAndEncryptFile implements SignAndEncryptFile {
  const factory _SignAndEncryptFile() = _$SignAndEncryptFileImpl;
}

/// @nodoc
mixin _$ProtectAES {}

/// @nodoc
abstract class $ProtectAESCopyWith<$Res> {
  factory $ProtectAESCopyWith(
          ProtectAES value, $Res Function(ProtectAES) then) =
      _$ProtectAESCopyWithImpl<$Res, ProtectAES>;
}

/// @nodoc
class _$ProtectAESCopyWithImpl<$Res, $Val extends ProtectAES>
    implements $ProtectAESCopyWith<$Res> {
  _$ProtectAESCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProtectAES
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ProtectAESImplCopyWith<$Res> {
  factory _$$ProtectAESImplCopyWith(
          _$ProtectAESImpl value, $Res Function(_$ProtectAESImpl) then) =
      __$$ProtectAESImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProtectAESImplCopyWithImpl<$Res>
    extends _$ProtectAESCopyWithImpl<$Res, _$ProtectAESImpl>
    implements _$$ProtectAESImplCopyWith<$Res> {
  __$$ProtectAESImplCopyWithImpl(
      _$ProtectAESImpl _value, $Res Function(_$ProtectAESImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProtectAES
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ProtectAESImpl with DiagnosticableTreeMixin implements _ProtectAES {
  const _$ProtectAESImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ProtectAES()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ProtectAES'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ProtectAESImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _ProtectAES implements ProtectAES {
  const factory _ProtectAES() = _$ProtectAESImpl;
}

/// @nodoc
mixin _$SendPackage {}

/// @nodoc
abstract class $SendPackageCopyWith<$Res> {
  factory $SendPackageCopyWith(
          SendPackage value, $Res Function(SendPackage) then) =
      _$SendPackageCopyWithImpl<$Res, SendPackage>;
}

/// @nodoc
class _$SendPackageCopyWithImpl<$Res, $Val extends SendPackage>
    implements $SendPackageCopyWith<$Res> {
  _$SendPackageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SendPackage
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SendPackageImplCopyWith<$Res> {
  factory _$$SendPackageImplCopyWith(
          _$SendPackageImpl value, $Res Function(_$SendPackageImpl) then) =
      __$$SendPackageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SendPackageImplCopyWithImpl<$Res>
    extends _$SendPackageCopyWithImpl<$Res, _$SendPackageImpl>
    implements _$$SendPackageImplCopyWith<$Res> {
  __$$SendPackageImplCopyWithImpl(
      _$SendPackageImpl _value, $Res Function(_$SendPackageImpl) _then)
      : super(_value, _then);

  /// Create a copy of SendPackage
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SendPackageImpl with DiagnosticableTreeMixin implements _SendPackage {
  const _$SendPackageImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SendPackage()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'SendPackage'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SendPackageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _SendPackage implements SendPackage {
  const factory _SendPackage() = _$SendPackageImpl;
}

/// @nodoc
mixin _$SelectTeacherPrivateKeyFile {}

/// @nodoc
abstract class $SelectTeacherPrivateKeyFileCopyWith<$Res> {
  factory $SelectTeacherPrivateKeyFileCopyWith(
          SelectTeacherPrivateKeyFile value,
          $Res Function(SelectTeacherPrivateKeyFile) then) =
      _$SelectTeacherPrivateKeyFileCopyWithImpl<$Res,
          SelectTeacherPrivateKeyFile>;
}

/// @nodoc
class _$SelectTeacherPrivateKeyFileCopyWithImpl<$Res,
        $Val extends SelectTeacherPrivateKeyFile>
    implements $SelectTeacherPrivateKeyFileCopyWith<$Res> {
  _$SelectTeacherPrivateKeyFileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SelectTeacherPrivateKeyFile
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SelectTeacherPrivateKeyFileImplCopyWith<$Res> {
  factory _$$SelectTeacherPrivateKeyFileImplCopyWith(
          _$SelectTeacherPrivateKeyFileImpl value,
          $Res Function(_$SelectTeacherPrivateKeyFileImpl) then) =
      __$$SelectTeacherPrivateKeyFileImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectTeacherPrivateKeyFileImplCopyWithImpl<$Res>
    extends _$SelectTeacherPrivateKeyFileCopyWithImpl<$Res,
        _$SelectTeacherPrivateKeyFileImpl>
    implements _$$SelectTeacherPrivateKeyFileImplCopyWith<$Res> {
  __$$SelectTeacherPrivateKeyFileImplCopyWithImpl(
      _$SelectTeacherPrivateKeyFileImpl _value,
      $Res Function(_$SelectTeacherPrivateKeyFileImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectTeacherPrivateKeyFile
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SelectTeacherPrivateKeyFileImpl
    with DiagnosticableTreeMixin
    implements _SelectTeacherPrivateKeyFile {
  const _$SelectTeacherPrivateKeyFileImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectTeacherPrivateKeyFile()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'SelectTeacherPrivateKeyFile'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectTeacherPrivateKeyFileImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _SelectTeacherPrivateKeyFile
    implements SelectTeacherPrivateKeyFile {
  const factory _SelectTeacherPrivateKeyFile() =
      _$SelectTeacherPrivateKeyFileImpl;
}

/// @nodoc
mixin _$CheckPackage {}

/// @nodoc
abstract class $CheckPackageCopyWith<$Res> {
  factory $CheckPackageCopyWith(
          CheckPackage value, $Res Function(CheckPackage) then) =
      _$CheckPackageCopyWithImpl<$Res, CheckPackage>;
}

/// @nodoc
class _$CheckPackageCopyWithImpl<$Res, $Val extends CheckPackage>
    implements $CheckPackageCopyWith<$Res> {
  _$CheckPackageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CheckPackage
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$CheckPackageImplCopyWith<$Res> {
  factory _$$CheckPackageImplCopyWith(
          _$CheckPackageImpl value, $Res Function(_$CheckPackageImpl) then) =
      __$$CheckPackageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CheckPackageImplCopyWithImpl<$Res>
    extends _$CheckPackageCopyWithImpl<$Res, _$CheckPackageImpl>
    implements _$$CheckPackageImplCopyWith<$Res> {
  __$$CheckPackageImplCopyWithImpl(
      _$CheckPackageImpl _value, $Res Function(_$CheckPackageImpl) _then)
      : super(_value, _then);

  /// Create a copy of CheckPackage
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CheckPackageImpl with DiagnosticableTreeMixin implements _CheckPackage {
  const _$CheckPackageImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CheckPackage()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'CheckPackage'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CheckPackageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _CheckPackage implements CheckPackage {
  const factory _CheckPackage() = _$CheckPackageImpl;
}

/// @nodoc
mixin _$KeyGeneration {
  String? get publicKey => throw _privateConstructorUsedError;
  String? get privateKey => throw _privateConstructorUsedError;
  String? get symmetricKey => throw _privateConstructorUsedError;

  /// Create a copy of KeyGeneration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $KeyGenerationCopyWith<KeyGeneration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KeyGenerationCopyWith<$Res> {
  factory $KeyGenerationCopyWith(
          KeyGeneration value, $Res Function(KeyGeneration) then) =
      _$KeyGenerationCopyWithImpl<$Res, KeyGeneration>;
  @useResult
  $Res call({String? publicKey, String? privateKey, String? symmetricKey});
}

/// @nodoc
class _$KeyGenerationCopyWithImpl<$Res, $Val extends KeyGeneration>
    implements $KeyGenerationCopyWith<$Res> {
  _$KeyGenerationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of KeyGeneration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = freezed,
    Object? privateKey = freezed,
    Object? symmetricKey = freezed,
  }) {
    return _then(_value.copyWith(
      publicKey: freezed == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String?,
      privateKey: freezed == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String?,
      symmetricKey: freezed == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$KeyGenerationImplCopyWith<$Res>
    implements $KeyGenerationCopyWith<$Res> {
  factory _$$KeyGenerationImplCopyWith(
          _$KeyGenerationImpl value, $Res Function(_$KeyGenerationImpl) then) =
      __$$KeyGenerationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? publicKey, String? privateKey, String? symmetricKey});
}

/// @nodoc
class __$$KeyGenerationImplCopyWithImpl<$Res>
    extends _$KeyGenerationCopyWithImpl<$Res, _$KeyGenerationImpl>
    implements _$$KeyGenerationImplCopyWith<$Res> {
  __$$KeyGenerationImplCopyWithImpl(
      _$KeyGenerationImpl _value, $Res Function(_$KeyGenerationImpl) _then)
      : super(_value, _then);

  /// Create a copy of KeyGeneration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = freezed,
    Object? privateKey = freezed,
    Object? symmetricKey = freezed,
  }) {
    return _then(_$KeyGenerationImpl(
      publicKey: freezed == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String?,
      privateKey: freezed == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String?,
      symmetricKey: freezed == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$KeyGenerationImpl
    with DiagnosticableTreeMixin
    implements _KeyGeneration {
  const _$KeyGenerationImpl(
      {this.publicKey, this.privateKey, this.symmetricKey});

  @override
  final String? publicKey;
  @override
  final String? privateKey;
  @override
  final String? symmetricKey;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'KeyGeneration(publicKey: $publicKey, privateKey: $privateKey, symmetricKey: $symmetricKey)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'KeyGeneration'))
      ..add(DiagnosticsProperty('publicKey', publicKey))
      ..add(DiagnosticsProperty('privateKey', privateKey))
      ..add(DiagnosticsProperty('symmetricKey', symmetricKey));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KeyGenerationImpl &&
            (identical(other.publicKey, publicKey) ||
                other.publicKey == publicKey) &&
            (identical(other.privateKey, privateKey) ||
                other.privateKey == privateKey) &&
            (identical(other.symmetricKey, symmetricKey) ||
                other.symmetricKey == symmetricKey));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, publicKey, privateKey, symmetricKey);

  /// Create a copy of KeyGeneration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$KeyGenerationImplCopyWith<_$KeyGenerationImpl> get copyWith =>
      __$$KeyGenerationImplCopyWithImpl<_$KeyGenerationImpl>(this, _$identity);
}

abstract class _KeyGeneration implements KeyGeneration {
  const factory _KeyGeneration(
      {final String? publicKey,
      final String? privateKey,
      final String? symmetricKey}) = _$KeyGenerationImpl;

  @override
  String? get publicKey;
  @override
  String? get privateKey;
  @override
  String? get symmetricKey;

  /// Create a copy of KeyGeneration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$KeyGenerationImplCopyWith<_$KeyGenerationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Preparation {
  String get publicKey => throw _privateConstructorUsedError;
  String get privateKey => throw _privateConstructorUsedError;
  String get symmetricKey => throw _privateConstructorUsedError;
  FileReader? get teacherPublicKeyFile => throw _privateConstructorUsedError;
  bool get selectingTeacherPublicKeyFile => throw _privateConstructorUsedError;
  FileReader? get fileToSend => throw _privateConstructorUsedError;
  bool get selectingFileToSend => throw _privateConstructorUsedError;

  /// Create a copy of Preparation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PreparationCopyWith<Preparation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PreparationCopyWith<$Res> {
  factory $PreparationCopyWith(
          Preparation value, $Res Function(Preparation) then) =
      _$PreparationCopyWithImpl<$Res, Preparation>;
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader? teacherPublicKeyFile,
      bool selectingTeacherPublicKeyFile,
      FileReader? fileToSend,
      bool selectingFileToSend});

  $FileReaderCopyWith<$Res>? get teacherPublicKeyFile;
  $FileReaderCopyWith<$Res>? get fileToSend;
}

/// @nodoc
class _$PreparationCopyWithImpl<$Res, $Val extends Preparation>
    implements $PreparationCopyWith<$Res> {
  _$PreparationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Preparation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? teacherPublicKeyFile = freezed,
    Object? selectingTeacherPublicKeyFile = null,
    Object? fileToSend = freezed,
    Object? selectingFileToSend = null,
  }) {
    return _then(_value.copyWith(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      teacherPublicKeyFile: freezed == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader?,
      selectingTeacherPublicKeyFile: null == selectingTeacherPublicKeyFile
          ? _value.selectingTeacherPublicKeyFile
          : selectingTeacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as bool,
      fileToSend: freezed == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader?,
      selectingFileToSend: null == selectingFileToSend
          ? _value.selectingFileToSend
          : selectingFileToSend // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  /// Create a copy of Preparation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res>? get teacherPublicKeyFile {
    if (_value.teacherPublicKeyFile == null) {
      return null;
    }

    return $FileReaderCopyWith<$Res>(_value.teacherPublicKeyFile!, (value) {
      return _then(_value.copyWith(teacherPublicKeyFile: value) as $Val);
    });
  }

  /// Create a copy of Preparation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res>? get fileToSend {
    if (_value.fileToSend == null) {
      return null;
    }

    return $FileReaderCopyWith<$Res>(_value.fileToSend!, (value) {
      return _then(_value.copyWith(fileToSend: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PreparationImplCopyWith<$Res>
    implements $PreparationCopyWith<$Res> {
  factory _$$PreparationImplCopyWith(
          _$PreparationImpl value, $Res Function(_$PreparationImpl) then) =
      __$$PreparationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader? teacherPublicKeyFile,
      bool selectingTeacherPublicKeyFile,
      FileReader? fileToSend,
      bool selectingFileToSend});

  @override
  $FileReaderCopyWith<$Res>? get teacherPublicKeyFile;
  @override
  $FileReaderCopyWith<$Res>? get fileToSend;
}

/// @nodoc
class __$$PreparationImplCopyWithImpl<$Res>
    extends _$PreparationCopyWithImpl<$Res, _$PreparationImpl>
    implements _$$PreparationImplCopyWith<$Res> {
  __$$PreparationImplCopyWithImpl(
      _$PreparationImpl _value, $Res Function(_$PreparationImpl) _then)
      : super(_value, _then);

  /// Create a copy of Preparation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? teacherPublicKeyFile = freezed,
    Object? selectingTeacherPublicKeyFile = null,
    Object? fileToSend = freezed,
    Object? selectingFileToSend = null,
  }) {
    return _then(_$PreparationImpl(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      teacherPublicKeyFile: freezed == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader?,
      selectingTeacherPublicKeyFile: null == selectingTeacherPublicKeyFile
          ? _value.selectingTeacherPublicKeyFile
          : selectingTeacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as bool,
      fileToSend: freezed == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader?,
      selectingFileToSend: null == selectingFileToSend
          ? _value.selectingFileToSend
          : selectingFileToSend // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$PreparationImpl with DiagnosticableTreeMixin implements _Preparation {
  const _$PreparationImpl(
      {required this.publicKey,
      required this.privateKey,
      required this.symmetricKey,
      this.teacherPublicKeyFile,
      this.selectingTeacherPublicKeyFile = false,
      this.fileToSend,
      this.selectingFileToSend = false});

  @override
  final String publicKey;
  @override
  final String privateKey;
  @override
  final String symmetricKey;
  @override
  final FileReader? teacherPublicKeyFile;
  @override
  @JsonKey()
  final bool selectingTeacherPublicKeyFile;
  @override
  final FileReader? fileToSend;
  @override
  @JsonKey()
  final bool selectingFileToSend;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Preparation(publicKey: $publicKey, privateKey: $privateKey, symmetricKey: $symmetricKey, teacherPublicKeyFile: $teacherPublicKeyFile, selectingTeacherPublicKeyFile: $selectingTeacherPublicKeyFile, fileToSend: $fileToSend, selectingFileToSend: $selectingFileToSend)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Preparation'))
      ..add(DiagnosticsProperty('publicKey', publicKey))
      ..add(DiagnosticsProperty('privateKey', privateKey))
      ..add(DiagnosticsProperty('symmetricKey', symmetricKey))
      ..add(DiagnosticsProperty('teacherPublicKeyFile', teacherPublicKeyFile))
      ..add(DiagnosticsProperty(
          'selectingTeacherPublicKeyFile', selectingTeacherPublicKeyFile))
      ..add(DiagnosticsProperty('fileToSend', fileToSend))
      ..add(DiagnosticsProperty('selectingFileToSend', selectingFileToSend));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PreparationImpl &&
            (identical(other.publicKey, publicKey) ||
                other.publicKey == publicKey) &&
            (identical(other.privateKey, privateKey) ||
                other.privateKey == privateKey) &&
            (identical(other.symmetricKey, symmetricKey) ||
                other.symmetricKey == symmetricKey) &&
            (identical(other.teacherPublicKeyFile, teacherPublicKeyFile) ||
                other.teacherPublicKeyFile == teacherPublicKeyFile) &&
            (identical(other.selectingTeacherPublicKeyFile,
                    selectingTeacherPublicKeyFile) ||
                other.selectingTeacherPublicKeyFile ==
                    selectingTeacherPublicKeyFile) &&
            (identical(other.fileToSend, fileToSend) ||
                other.fileToSend == fileToSend) &&
            (identical(other.selectingFileToSend, selectingFileToSend) ||
                other.selectingFileToSend == selectingFileToSend));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      publicKey,
      privateKey,
      symmetricKey,
      teacherPublicKeyFile,
      selectingTeacherPublicKeyFile,
      fileToSend,
      selectingFileToSend);

  /// Create a copy of Preparation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PreparationImplCopyWith<_$PreparationImpl> get copyWith =>
      __$$PreparationImplCopyWithImpl<_$PreparationImpl>(this, _$identity);
}

abstract class _Preparation implements Preparation {
  const factory _Preparation(
      {required final String publicKey,
      required final String privateKey,
      required final String symmetricKey,
      final FileReader? teacherPublicKeyFile,
      final bool selectingTeacherPublicKeyFile,
      final FileReader? fileToSend,
      final bool selectingFileToSend}) = _$PreparationImpl;

  @override
  String get publicKey;
  @override
  String get privateKey;
  @override
  String get symmetricKey;
  @override
  FileReader? get teacherPublicKeyFile;
  @override
  bool get selectingTeacherPublicKeyFile;
  @override
  FileReader? get fileToSend;
  @override
  bool get selectingFileToSend;

  /// Create a copy of Preparation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PreparationImplCopyWith<_$PreparationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Signature {
  String get publicKey => throw _privateConstructorUsedError;
  String get privateKey => throw _privateConstructorUsedError;
  String get symmetricKey => throw _privateConstructorUsedError;
  FileReader get fileToSend => throw _privateConstructorUsedError;
  FileReader get teacherPublicKeyFile => throw _privateConstructorUsedError;
  String? get fileDigest => throw _privateConstructorUsedError;
  String? get fileSignature => throw _privateConstructorUsedError;
  String? get fileEncryption => throw _privateConstructorUsedError;

  /// Create a copy of Signature
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SignatureCopyWith<Signature> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SignatureCopyWith<$Res> {
  factory $SignatureCopyWith(Signature value, $Res Function(Signature) then) =
      _$SignatureCopyWithImpl<$Res, Signature>;
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader fileToSend,
      FileReader teacherPublicKeyFile,
      String? fileDigest,
      String? fileSignature,
      String? fileEncryption});

  $FileReaderCopyWith<$Res> get fileToSend;
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile;
}

/// @nodoc
class _$SignatureCopyWithImpl<$Res, $Val extends Signature>
    implements $SignatureCopyWith<$Res> {
  _$SignatureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Signature
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? fileToSend = null,
    Object? teacherPublicKeyFile = null,
    Object? fileDigest = freezed,
    Object? fileSignature = freezed,
    Object? fileEncryption = freezed,
  }) {
    return _then(_value.copyWith(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      fileToSend: null == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader,
      teacherPublicKeyFile: null == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader,
      fileDigest: freezed == fileDigest
          ? _value.fileDigest
          : fileDigest // ignore: cast_nullable_to_non_nullable
              as String?,
      fileSignature: freezed == fileSignature
          ? _value.fileSignature
          : fileSignature // ignore: cast_nullable_to_non_nullable
              as String?,
      fileEncryption: freezed == fileEncryption
          ? _value.fileEncryption
          : fileEncryption // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of Signature
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res> get fileToSend {
    return $FileReaderCopyWith<$Res>(_value.fileToSend, (value) {
      return _then(_value.copyWith(fileToSend: value) as $Val);
    });
  }

  /// Create a copy of Signature
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile {
    return $FileReaderCopyWith<$Res>(_value.teacherPublicKeyFile, (value) {
      return _then(_value.copyWith(teacherPublicKeyFile: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$SignatureImplCopyWith<$Res>
    implements $SignatureCopyWith<$Res> {
  factory _$$SignatureImplCopyWith(
          _$SignatureImpl value, $Res Function(_$SignatureImpl) then) =
      __$$SignatureImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader fileToSend,
      FileReader teacherPublicKeyFile,
      String? fileDigest,
      String? fileSignature,
      String? fileEncryption});

  @override
  $FileReaderCopyWith<$Res> get fileToSend;
  @override
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile;
}

/// @nodoc
class __$$SignatureImplCopyWithImpl<$Res>
    extends _$SignatureCopyWithImpl<$Res, _$SignatureImpl>
    implements _$$SignatureImplCopyWith<$Res> {
  __$$SignatureImplCopyWithImpl(
      _$SignatureImpl _value, $Res Function(_$SignatureImpl) _then)
      : super(_value, _then);

  /// Create a copy of Signature
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? fileToSend = null,
    Object? teacherPublicKeyFile = null,
    Object? fileDigest = freezed,
    Object? fileSignature = freezed,
    Object? fileEncryption = freezed,
  }) {
    return _then(_$SignatureImpl(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      fileToSend: null == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader,
      teacherPublicKeyFile: null == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader,
      fileDigest: freezed == fileDigest
          ? _value.fileDigest
          : fileDigest // ignore: cast_nullable_to_non_nullable
              as String?,
      fileSignature: freezed == fileSignature
          ? _value.fileSignature
          : fileSignature // ignore: cast_nullable_to_non_nullable
              as String?,
      fileEncryption: freezed == fileEncryption
          ? _value.fileEncryption
          : fileEncryption // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$SignatureImpl with DiagnosticableTreeMixin implements _Signature {
  const _$SignatureImpl(
      {required this.publicKey,
      required this.privateKey,
      required this.symmetricKey,
      required this.fileToSend,
      required this.teacherPublicKeyFile,
      this.fileDigest,
      this.fileSignature,
      this.fileEncryption});

  @override
  final String publicKey;
  @override
  final String privateKey;
  @override
  final String symmetricKey;
  @override
  final FileReader fileToSend;
  @override
  final FileReader teacherPublicKeyFile;
  @override
  final String? fileDigest;
  @override
  final String? fileSignature;
  @override
  final String? fileEncryption;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Signature(publicKey: $publicKey, privateKey: $privateKey, symmetricKey: $symmetricKey, fileToSend: $fileToSend, teacherPublicKeyFile: $teacherPublicKeyFile, fileDigest: $fileDigest, fileSignature: $fileSignature, fileEncryption: $fileEncryption)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Signature'))
      ..add(DiagnosticsProperty('publicKey', publicKey))
      ..add(DiagnosticsProperty('privateKey', privateKey))
      ..add(DiagnosticsProperty('symmetricKey', symmetricKey))
      ..add(DiagnosticsProperty('fileToSend', fileToSend))
      ..add(DiagnosticsProperty('teacherPublicKeyFile', teacherPublicKeyFile))
      ..add(DiagnosticsProperty('fileDigest', fileDigest))
      ..add(DiagnosticsProperty('fileSignature', fileSignature))
      ..add(DiagnosticsProperty('fileEncryption', fileEncryption));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SignatureImpl &&
            (identical(other.publicKey, publicKey) ||
                other.publicKey == publicKey) &&
            (identical(other.privateKey, privateKey) ||
                other.privateKey == privateKey) &&
            (identical(other.symmetricKey, symmetricKey) ||
                other.symmetricKey == symmetricKey) &&
            (identical(other.fileToSend, fileToSend) ||
                other.fileToSend == fileToSend) &&
            (identical(other.teacherPublicKeyFile, teacherPublicKeyFile) ||
                other.teacherPublicKeyFile == teacherPublicKeyFile) &&
            (identical(other.fileDigest, fileDigest) ||
                other.fileDigest == fileDigest) &&
            (identical(other.fileSignature, fileSignature) ||
                other.fileSignature == fileSignature) &&
            (identical(other.fileEncryption, fileEncryption) ||
                other.fileEncryption == fileEncryption));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      publicKey,
      privateKey,
      symmetricKey,
      fileToSend,
      teacherPublicKeyFile,
      fileDigest,
      fileSignature,
      fileEncryption);

  /// Create a copy of Signature
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SignatureImplCopyWith<_$SignatureImpl> get copyWith =>
      __$$SignatureImplCopyWithImpl<_$SignatureImpl>(this, _$identity);
}

abstract class _Signature implements Signature {
  const factory _Signature(
      {required final String publicKey,
      required final String privateKey,
      required final String symmetricKey,
      required final FileReader fileToSend,
      required final FileReader teacherPublicKeyFile,
      final String? fileDigest,
      final String? fileSignature,
      final String? fileEncryption}) = _$SignatureImpl;

  @override
  String get publicKey;
  @override
  String get privateKey;
  @override
  String get symmetricKey;
  @override
  FileReader get fileToSend;
  @override
  FileReader get teacherPublicKeyFile;
  @override
  String? get fileDigest;
  @override
  String? get fileSignature;
  @override
  String? get fileEncryption;

  /// Create a copy of Signature
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SignatureImplCopyWith<_$SignatureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Protection {
  String get publicKey => throw _privateConstructorUsedError;
  String get privateKey => throw _privateConstructorUsedError;
  String get symmetricKey => throw _privateConstructorUsedError;
  FileReader get fileToSend => throw _privateConstructorUsedError;
  FileReader get teacherPublicKeyFile => throw _privateConstructorUsedError;
  String get fileDigest => throw _privateConstructorUsedError;
  String get fileSignature => throw _privateConstructorUsedError;
  String get fileEncryption => throw _privateConstructorUsedError;
  String? get symmetricKeyEncryption => throw _privateConstructorUsedError;

  /// Create a copy of Protection
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProtectionCopyWith<Protection> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProtectionCopyWith<$Res> {
  factory $ProtectionCopyWith(
          Protection value, $Res Function(Protection) then) =
      _$ProtectionCopyWithImpl<$Res, Protection>;
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader fileToSend,
      FileReader teacherPublicKeyFile,
      String fileDigest,
      String fileSignature,
      String fileEncryption,
      String? symmetricKeyEncryption});

  $FileReaderCopyWith<$Res> get fileToSend;
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile;
}

/// @nodoc
class _$ProtectionCopyWithImpl<$Res, $Val extends Protection>
    implements $ProtectionCopyWith<$Res> {
  _$ProtectionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Protection
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? fileToSend = null,
    Object? teacherPublicKeyFile = null,
    Object? fileDigest = null,
    Object? fileSignature = null,
    Object? fileEncryption = null,
    Object? symmetricKeyEncryption = freezed,
  }) {
    return _then(_value.copyWith(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      fileToSend: null == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader,
      teacherPublicKeyFile: null == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader,
      fileDigest: null == fileDigest
          ? _value.fileDigest
          : fileDigest // ignore: cast_nullable_to_non_nullable
              as String,
      fileSignature: null == fileSignature
          ? _value.fileSignature
          : fileSignature // ignore: cast_nullable_to_non_nullable
              as String,
      fileEncryption: null == fileEncryption
          ? _value.fileEncryption
          : fileEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKeyEncryption: freezed == symmetricKeyEncryption
          ? _value.symmetricKeyEncryption
          : symmetricKeyEncryption // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of Protection
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res> get fileToSend {
    return $FileReaderCopyWith<$Res>(_value.fileToSend, (value) {
      return _then(_value.copyWith(fileToSend: value) as $Val);
    });
  }

  /// Create a copy of Protection
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile {
    return $FileReaderCopyWith<$Res>(_value.teacherPublicKeyFile, (value) {
      return _then(_value.copyWith(teacherPublicKeyFile: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ProtectionImplCopyWith<$Res>
    implements $ProtectionCopyWith<$Res> {
  factory _$$ProtectionImplCopyWith(
          _$ProtectionImpl value, $Res Function(_$ProtectionImpl) then) =
      __$$ProtectionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader fileToSend,
      FileReader teacherPublicKeyFile,
      String fileDigest,
      String fileSignature,
      String fileEncryption,
      String? symmetricKeyEncryption});

  @override
  $FileReaderCopyWith<$Res> get fileToSend;
  @override
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile;
}

/// @nodoc
class __$$ProtectionImplCopyWithImpl<$Res>
    extends _$ProtectionCopyWithImpl<$Res, _$ProtectionImpl>
    implements _$$ProtectionImplCopyWith<$Res> {
  __$$ProtectionImplCopyWithImpl(
      _$ProtectionImpl _value, $Res Function(_$ProtectionImpl) _then)
      : super(_value, _then);

  /// Create a copy of Protection
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? fileToSend = null,
    Object? teacherPublicKeyFile = null,
    Object? fileDigest = null,
    Object? fileSignature = null,
    Object? fileEncryption = null,
    Object? symmetricKeyEncryption = freezed,
  }) {
    return _then(_$ProtectionImpl(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      fileToSend: null == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader,
      teacherPublicKeyFile: null == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader,
      fileDigest: null == fileDigest
          ? _value.fileDigest
          : fileDigest // ignore: cast_nullable_to_non_nullable
              as String,
      fileSignature: null == fileSignature
          ? _value.fileSignature
          : fileSignature // ignore: cast_nullable_to_non_nullable
              as String,
      fileEncryption: null == fileEncryption
          ? _value.fileEncryption
          : fileEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKeyEncryption: freezed == symmetricKeyEncryption
          ? _value.symmetricKeyEncryption
          : symmetricKeyEncryption // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ProtectionImpl with DiagnosticableTreeMixin implements _Protection {
  const _$ProtectionImpl(
      {required this.publicKey,
      required this.privateKey,
      required this.symmetricKey,
      required this.fileToSend,
      required this.teacherPublicKeyFile,
      required this.fileDigest,
      required this.fileSignature,
      required this.fileEncryption,
      this.symmetricKeyEncryption});

  @override
  final String publicKey;
  @override
  final String privateKey;
  @override
  final String symmetricKey;
  @override
  final FileReader fileToSend;
  @override
  final FileReader teacherPublicKeyFile;
  @override
  final String fileDigest;
  @override
  final String fileSignature;
  @override
  final String fileEncryption;
  @override
  final String? symmetricKeyEncryption;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Protection(publicKey: $publicKey, privateKey: $privateKey, symmetricKey: $symmetricKey, fileToSend: $fileToSend, teacherPublicKeyFile: $teacherPublicKeyFile, fileDigest: $fileDigest, fileSignature: $fileSignature, fileEncryption: $fileEncryption, symmetricKeyEncryption: $symmetricKeyEncryption)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Protection'))
      ..add(DiagnosticsProperty('publicKey', publicKey))
      ..add(DiagnosticsProperty('privateKey', privateKey))
      ..add(DiagnosticsProperty('symmetricKey', symmetricKey))
      ..add(DiagnosticsProperty('fileToSend', fileToSend))
      ..add(DiagnosticsProperty('teacherPublicKeyFile', teacherPublicKeyFile))
      ..add(DiagnosticsProperty('fileDigest', fileDigest))
      ..add(DiagnosticsProperty('fileSignature', fileSignature))
      ..add(DiagnosticsProperty('fileEncryption', fileEncryption))
      ..add(DiagnosticsProperty(
          'symmetricKeyEncryption', symmetricKeyEncryption));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProtectionImpl &&
            (identical(other.publicKey, publicKey) ||
                other.publicKey == publicKey) &&
            (identical(other.privateKey, privateKey) ||
                other.privateKey == privateKey) &&
            (identical(other.symmetricKey, symmetricKey) ||
                other.symmetricKey == symmetricKey) &&
            (identical(other.fileToSend, fileToSend) ||
                other.fileToSend == fileToSend) &&
            (identical(other.teacherPublicKeyFile, teacherPublicKeyFile) ||
                other.teacherPublicKeyFile == teacherPublicKeyFile) &&
            (identical(other.fileDigest, fileDigest) ||
                other.fileDigest == fileDigest) &&
            (identical(other.fileSignature, fileSignature) ||
                other.fileSignature == fileSignature) &&
            (identical(other.fileEncryption, fileEncryption) ||
                other.fileEncryption == fileEncryption) &&
            (identical(other.symmetricKeyEncryption, symmetricKeyEncryption) ||
                other.symmetricKeyEncryption == symmetricKeyEncryption));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      publicKey,
      privateKey,
      symmetricKey,
      fileToSend,
      teacherPublicKeyFile,
      fileDigest,
      fileSignature,
      fileEncryption,
      symmetricKeyEncryption);

  /// Create a copy of Protection
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProtectionImplCopyWith<_$ProtectionImpl> get copyWith =>
      __$$ProtectionImplCopyWithImpl<_$ProtectionImpl>(this, _$identity);
}

abstract class _Protection implements Protection {
  const factory _Protection(
      {required final String publicKey,
      required final String privateKey,
      required final String symmetricKey,
      required final FileReader fileToSend,
      required final FileReader teacherPublicKeyFile,
      required final String fileDigest,
      required final String fileSignature,
      required final String fileEncryption,
      final String? symmetricKeyEncryption}) = _$ProtectionImpl;

  @override
  String get publicKey;
  @override
  String get privateKey;
  @override
  String get symmetricKey;
  @override
  FileReader get fileToSend;
  @override
  FileReader get teacherPublicKeyFile;
  @override
  String get fileDigest;
  @override
  String get fileSignature;
  @override
  String get fileEncryption;
  @override
  String? get symmetricKeyEncryption;

  /// Create a copy of Protection
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProtectionImplCopyWith<_$ProtectionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Shipping {
  String get publicKey => throw _privateConstructorUsedError;
  String get privateKey => throw _privateConstructorUsedError;
  String get symmetricKey => throw _privateConstructorUsedError;
  FileReader get fileToSend => throw _privateConstructorUsedError;
  FileReader get teacherPublicKeyFile => throw _privateConstructorUsedError;
  String get fileDigest => throw _privateConstructorUsedError;
  String get fileSignature => throw _privateConstructorUsedError;
  String get fileEncryption => throw _privateConstructorUsedError;
  String get symmetricKeyEncryption => throw _privateConstructorUsedError;
  bool get packageSended => throw _privateConstructorUsedError;

  /// Create a copy of Shipping
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ShippingCopyWith<Shipping> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShippingCopyWith<$Res> {
  factory $ShippingCopyWith(Shipping value, $Res Function(Shipping) then) =
      _$ShippingCopyWithImpl<$Res, Shipping>;
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader fileToSend,
      FileReader teacherPublicKeyFile,
      String fileDigest,
      String fileSignature,
      String fileEncryption,
      String symmetricKeyEncryption,
      bool packageSended});

  $FileReaderCopyWith<$Res> get fileToSend;
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile;
}

/// @nodoc
class _$ShippingCopyWithImpl<$Res, $Val extends Shipping>
    implements $ShippingCopyWith<$Res> {
  _$ShippingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Shipping
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? fileToSend = null,
    Object? teacherPublicKeyFile = null,
    Object? fileDigest = null,
    Object? fileSignature = null,
    Object? fileEncryption = null,
    Object? symmetricKeyEncryption = null,
    Object? packageSended = null,
  }) {
    return _then(_value.copyWith(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      fileToSend: null == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader,
      teacherPublicKeyFile: null == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader,
      fileDigest: null == fileDigest
          ? _value.fileDigest
          : fileDigest // ignore: cast_nullable_to_non_nullable
              as String,
      fileSignature: null == fileSignature
          ? _value.fileSignature
          : fileSignature // ignore: cast_nullable_to_non_nullable
              as String,
      fileEncryption: null == fileEncryption
          ? _value.fileEncryption
          : fileEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKeyEncryption: null == symmetricKeyEncryption
          ? _value.symmetricKeyEncryption
          : symmetricKeyEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      packageSended: null == packageSended
          ? _value.packageSended
          : packageSended // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  /// Create a copy of Shipping
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res> get fileToSend {
    return $FileReaderCopyWith<$Res>(_value.fileToSend, (value) {
      return _then(_value.copyWith(fileToSend: value) as $Val);
    });
  }

  /// Create a copy of Shipping
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile {
    return $FileReaderCopyWith<$Res>(_value.teacherPublicKeyFile, (value) {
      return _then(_value.copyWith(teacherPublicKeyFile: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ShippingImplCopyWith<$Res>
    implements $ShippingCopyWith<$Res> {
  factory _$$ShippingImplCopyWith(
          _$ShippingImpl value, $Res Function(_$ShippingImpl) then) =
      __$$ShippingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader fileToSend,
      FileReader teacherPublicKeyFile,
      String fileDigest,
      String fileSignature,
      String fileEncryption,
      String symmetricKeyEncryption,
      bool packageSended});

  @override
  $FileReaderCopyWith<$Res> get fileToSend;
  @override
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile;
}

/// @nodoc
class __$$ShippingImplCopyWithImpl<$Res>
    extends _$ShippingCopyWithImpl<$Res, _$ShippingImpl>
    implements _$$ShippingImplCopyWith<$Res> {
  __$$ShippingImplCopyWithImpl(
      _$ShippingImpl _value, $Res Function(_$ShippingImpl) _then)
      : super(_value, _then);

  /// Create a copy of Shipping
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? fileToSend = null,
    Object? teacherPublicKeyFile = null,
    Object? fileDigest = null,
    Object? fileSignature = null,
    Object? fileEncryption = null,
    Object? symmetricKeyEncryption = null,
    Object? packageSended = null,
  }) {
    return _then(_$ShippingImpl(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      fileToSend: null == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader,
      teacherPublicKeyFile: null == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader,
      fileDigest: null == fileDigest
          ? _value.fileDigest
          : fileDigest // ignore: cast_nullable_to_non_nullable
              as String,
      fileSignature: null == fileSignature
          ? _value.fileSignature
          : fileSignature // ignore: cast_nullable_to_non_nullable
              as String,
      fileEncryption: null == fileEncryption
          ? _value.fileEncryption
          : fileEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKeyEncryption: null == symmetricKeyEncryption
          ? _value.symmetricKeyEncryption
          : symmetricKeyEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      packageSended: null == packageSended
          ? _value.packageSended
          : packageSended // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ShippingImpl with DiagnosticableTreeMixin implements _Shipping {
  const _$ShippingImpl(
      {required this.publicKey,
      required this.privateKey,
      required this.symmetricKey,
      required this.fileToSend,
      required this.teacherPublicKeyFile,
      required this.fileDigest,
      required this.fileSignature,
      required this.fileEncryption,
      required this.symmetricKeyEncryption,
      this.packageSended = false});

  @override
  final String publicKey;
  @override
  final String privateKey;
  @override
  final String symmetricKey;
  @override
  final FileReader fileToSend;
  @override
  final FileReader teacherPublicKeyFile;
  @override
  final String fileDigest;
  @override
  final String fileSignature;
  @override
  final String fileEncryption;
  @override
  final String symmetricKeyEncryption;
  @override
  @JsonKey()
  final bool packageSended;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Shipping(publicKey: $publicKey, privateKey: $privateKey, symmetricKey: $symmetricKey, fileToSend: $fileToSend, teacherPublicKeyFile: $teacherPublicKeyFile, fileDigest: $fileDigest, fileSignature: $fileSignature, fileEncryption: $fileEncryption, symmetricKeyEncryption: $symmetricKeyEncryption, packageSended: $packageSended)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Shipping'))
      ..add(DiagnosticsProperty('publicKey', publicKey))
      ..add(DiagnosticsProperty('privateKey', privateKey))
      ..add(DiagnosticsProperty('symmetricKey', symmetricKey))
      ..add(DiagnosticsProperty('fileToSend', fileToSend))
      ..add(DiagnosticsProperty('teacherPublicKeyFile', teacherPublicKeyFile))
      ..add(DiagnosticsProperty('fileDigest', fileDigest))
      ..add(DiagnosticsProperty('fileSignature', fileSignature))
      ..add(DiagnosticsProperty('fileEncryption', fileEncryption))
      ..add(
          DiagnosticsProperty('symmetricKeyEncryption', symmetricKeyEncryption))
      ..add(DiagnosticsProperty('packageSended', packageSended));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShippingImpl &&
            (identical(other.publicKey, publicKey) ||
                other.publicKey == publicKey) &&
            (identical(other.privateKey, privateKey) ||
                other.privateKey == privateKey) &&
            (identical(other.symmetricKey, symmetricKey) ||
                other.symmetricKey == symmetricKey) &&
            (identical(other.fileToSend, fileToSend) ||
                other.fileToSend == fileToSend) &&
            (identical(other.teacherPublicKeyFile, teacherPublicKeyFile) ||
                other.teacherPublicKeyFile == teacherPublicKeyFile) &&
            (identical(other.fileDigest, fileDigest) ||
                other.fileDigest == fileDigest) &&
            (identical(other.fileSignature, fileSignature) ||
                other.fileSignature == fileSignature) &&
            (identical(other.fileEncryption, fileEncryption) ||
                other.fileEncryption == fileEncryption) &&
            (identical(other.symmetricKeyEncryption, symmetricKeyEncryption) ||
                other.symmetricKeyEncryption == symmetricKeyEncryption) &&
            (identical(other.packageSended, packageSended) ||
                other.packageSended == packageSended));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      publicKey,
      privateKey,
      symmetricKey,
      fileToSend,
      teacherPublicKeyFile,
      fileDigest,
      fileSignature,
      fileEncryption,
      symmetricKeyEncryption,
      packageSended);

  /// Create a copy of Shipping
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ShippingImplCopyWith<_$ShippingImpl> get copyWith =>
      __$$ShippingImplCopyWithImpl<_$ShippingImpl>(this, _$identity);
}

abstract class _Shipping implements Shipping {
  const factory _Shipping(
      {required final String publicKey,
      required final String privateKey,
      required final String symmetricKey,
      required final FileReader fileToSend,
      required final FileReader teacherPublicKeyFile,
      required final String fileDigest,
      required final String fileSignature,
      required final String fileEncryption,
      required final String symmetricKeyEncryption,
      final bool packageSended}) = _$ShippingImpl;

  @override
  String get publicKey;
  @override
  String get privateKey;
  @override
  String get symmetricKey;
  @override
  FileReader get fileToSend;
  @override
  FileReader get teacherPublicKeyFile;
  @override
  String get fileDigest;
  @override
  String get fileSignature;
  @override
  String get fileEncryption;
  @override
  String get symmetricKeyEncryption;
  @override
  bool get packageSended;

  /// Create a copy of Shipping
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ShippingImplCopyWith<_$ShippingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Decryption {
  String get publicKey => throw _privateConstructorUsedError;
  String get privateKey => throw _privateConstructorUsedError;
  String get symmetricKey => throw _privateConstructorUsedError;
  FileReader get fileToSend => throw _privateConstructorUsedError;
  FileReader get teacherPublicKeyFile => throw _privateConstructorUsedError;
  String get fileDigest => throw _privateConstructorUsedError;
  String get fileSignature => throw _privateConstructorUsedError;
  String get fileEncryption => throw _privateConstructorUsedError;
  String get symmetricKeyEncryption => throw _privateConstructorUsedError;
  FileReader? get teacherPrivateKeyFile => throw _privateConstructorUsedError;
  bool get selectingTeacherPrivateKeyFile => throw _privateConstructorUsedError;
  bool get validDecryption => throw _privateConstructorUsedError;

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DecryptionCopyWith<Decryption> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DecryptionCopyWith<$Res> {
  factory $DecryptionCopyWith(
          Decryption value, $Res Function(Decryption) then) =
      _$DecryptionCopyWithImpl<$Res, Decryption>;
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader fileToSend,
      FileReader teacherPublicKeyFile,
      String fileDigest,
      String fileSignature,
      String fileEncryption,
      String symmetricKeyEncryption,
      FileReader? teacherPrivateKeyFile,
      bool selectingTeacherPrivateKeyFile,
      bool validDecryption});

  $FileReaderCopyWith<$Res> get fileToSend;
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile;
  $FileReaderCopyWith<$Res>? get teacherPrivateKeyFile;
}

/// @nodoc
class _$DecryptionCopyWithImpl<$Res, $Val extends Decryption>
    implements $DecryptionCopyWith<$Res> {
  _$DecryptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? fileToSend = null,
    Object? teacherPublicKeyFile = null,
    Object? fileDigest = null,
    Object? fileSignature = null,
    Object? fileEncryption = null,
    Object? symmetricKeyEncryption = null,
    Object? teacherPrivateKeyFile = freezed,
    Object? selectingTeacherPrivateKeyFile = null,
    Object? validDecryption = null,
  }) {
    return _then(_value.copyWith(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      fileToSend: null == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader,
      teacherPublicKeyFile: null == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader,
      fileDigest: null == fileDigest
          ? _value.fileDigest
          : fileDigest // ignore: cast_nullable_to_non_nullable
              as String,
      fileSignature: null == fileSignature
          ? _value.fileSignature
          : fileSignature // ignore: cast_nullable_to_non_nullable
              as String,
      fileEncryption: null == fileEncryption
          ? _value.fileEncryption
          : fileEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKeyEncryption: null == symmetricKeyEncryption
          ? _value.symmetricKeyEncryption
          : symmetricKeyEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      teacherPrivateKeyFile: freezed == teacherPrivateKeyFile
          ? _value.teacherPrivateKeyFile
          : teacherPrivateKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader?,
      selectingTeacherPrivateKeyFile: null == selectingTeacherPrivateKeyFile
          ? _value.selectingTeacherPrivateKeyFile
          : selectingTeacherPrivateKeyFile // ignore: cast_nullable_to_non_nullable
              as bool,
      validDecryption: null == validDecryption
          ? _value.validDecryption
          : validDecryption // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res> get fileToSend {
    return $FileReaderCopyWith<$Res>(_value.fileToSend, (value) {
      return _then(_value.copyWith(fileToSend: value) as $Val);
    });
  }

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile {
    return $FileReaderCopyWith<$Res>(_value.teacherPublicKeyFile, (value) {
      return _then(_value.copyWith(teacherPublicKeyFile: value) as $Val);
    });
  }

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $FileReaderCopyWith<$Res>? get teacherPrivateKeyFile {
    if (_value.teacherPrivateKeyFile == null) {
      return null;
    }

    return $FileReaderCopyWith<$Res>(_value.teacherPrivateKeyFile!, (value) {
      return _then(_value.copyWith(teacherPrivateKeyFile: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$DecryptionImplCopyWith<$Res>
    implements $DecryptionCopyWith<$Res> {
  factory _$$DecryptionImplCopyWith(
          _$DecryptionImpl value, $Res Function(_$DecryptionImpl) then) =
      __$$DecryptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String publicKey,
      String privateKey,
      String symmetricKey,
      FileReader fileToSend,
      FileReader teacherPublicKeyFile,
      String fileDigest,
      String fileSignature,
      String fileEncryption,
      String symmetricKeyEncryption,
      FileReader? teacherPrivateKeyFile,
      bool selectingTeacherPrivateKeyFile,
      bool validDecryption});

  @override
  $FileReaderCopyWith<$Res> get fileToSend;
  @override
  $FileReaderCopyWith<$Res> get teacherPublicKeyFile;
  @override
  $FileReaderCopyWith<$Res>? get teacherPrivateKeyFile;
}

/// @nodoc
class __$$DecryptionImplCopyWithImpl<$Res>
    extends _$DecryptionCopyWithImpl<$Res, _$DecryptionImpl>
    implements _$$DecryptionImplCopyWith<$Res> {
  __$$DecryptionImplCopyWithImpl(
      _$DecryptionImpl _value, $Res Function(_$DecryptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
    Object? privateKey = null,
    Object? symmetricKey = null,
    Object? fileToSend = null,
    Object? teacherPublicKeyFile = null,
    Object? fileDigest = null,
    Object? fileSignature = null,
    Object? fileEncryption = null,
    Object? symmetricKeyEncryption = null,
    Object? teacherPrivateKeyFile = freezed,
    Object? selectingTeacherPrivateKeyFile = null,
    Object? validDecryption = null,
  }) {
    return _then(_$DecryptionImpl(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
      privateKey: null == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKey: null == symmetricKey
          ? _value.symmetricKey
          : symmetricKey // ignore: cast_nullable_to_non_nullable
              as String,
      fileToSend: null == fileToSend
          ? _value.fileToSend
          : fileToSend // ignore: cast_nullable_to_non_nullable
              as FileReader,
      teacherPublicKeyFile: null == teacherPublicKeyFile
          ? _value.teacherPublicKeyFile
          : teacherPublicKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader,
      fileDigest: null == fileDigest
          ? _value.fileDigest
          : fileDigest // ignore: cast_nullable_to_non_nullable
              as String,
      fileSignature: null == fileSignature
          ? _value.fileSignature
          : fileSignature // ignore: cast_nullable_to_non_nullable
              as String,
      fileEncryption: null == fileEncryption
          ? _value.fileEncryption
          : fileEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      symmetricKeyEncryption: null == symmetricKeyEncryption
          ? _value.symmetricKeyEncryption
          : symmetricKeyEncryption // ignore: cast_nullable_to_non_nullable
              as String,
      teacherPrivateKeyFile: freezed == teacherPrivateKeyFile
          ? _value.teacherPrivateKeyFile
          : teacherPrivateKeyFile // ignore: cast_nullable_to_non_nullable
              as FileReader?,
      selectingTeacherPrivateKeyFile: null == selectingTeacherPrivateKeyFile
          ? _value.selectingTeacherPrivateKeyFile
          : selectingTeacherPrivateKeyFile // ignore: cast_nullable_to_non_nullable
              as bool,
      validDecryption: null == validDecryption
          ? _value.validDecryption
          : validDecryption // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$DecryptionImpl with DiagnosticableTreeMixin implements _Decryption {
  const _$DecryptionImpl(
      {required this.publicKey,
      required this.privateKey,
      required this.symmetricKey,
      required this.fileToSend,
      required this.teacherPublicKeyFile,
      required this.fileDigest,
      required this.fileSignature,
      required this.fileEncryption,
      required this.symmetricKeyEncryption,
      this.teacherPrivateKeyFile,
      this.selectingTeacherPrivateKeyFile = false,
      this.validDecryption = false});

  @override
  final String publicKey;
  @override
  final String privateKey;
  @override
  final String symmetricKey;
  @override
  final FileReader fileToSend;
  @override
  final FileReader teacherPublicKeyFile;
  @override
  final String fileDigest;
  @override
  final String fileSignature;
  @override
  final String fileEncryption;
  @override
  final String symmetricKeyEncryption;
  @override
  final FileReader? teacherPrivateKeyFile;
  @override
  @JsonKey()
  final bool selectingTeacherPrivateKeyFile;
  @override
  @JsonKey()
  final bool validDecryption;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Decryption(publicKey: $publicKey, privateKey: $privateKey, symmetricKey: $symmetricKey, fileToSend: $fileToSend, teacherPublicKeyFile: $teacherPublicKeyFile, fileDigest: $fileDigest, fileSignature: $fileSignature, fileEncryption: $fileEncryption, symmetricKeyEncryption: $symmetricKeyEncryption, teacherPrivateKeyFile: $teacherPrivateKeyFile, selectingTeacherPrivateKeyFile: $selectingTeacherPrivateKeyFile, validDecryption: $validDecryption)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Decryption'))
      ..add(DiagnosticsProperty('publicKey', publicKey))
      ..add(DiagnosticsProperty('privateKey', privateKey))
      ..add(DiagnosticsProperty('symmetricKey', symmetricKey))
      ..add(DiagnosticsProperty('fileToSend', fileToSend))
      ..add(DiagnosticsProperty('teacherPublicKeyFile', teacherPublicKeyFile))
      ..add(DiagnosticsProperty('fileDigest', fileDigest))
      ..add(DiagnosticsProperty('fileSignature', fileSignature))
      ..add(DiagnosticsProperty('fileEncryption', fileEncryption))
      ..add(
          DiagnosticsProperty('symmetricKeyEncryption', symmetricKeyEncryption))
      ..add(DiagnosticsProperty('teacherPrivateKeyFile', teacherPrivateKeyFile))
      ..add(DiagnosticsProperty(
          'selectingTeacherPrivateKeyFile', selectingTeacherPrivateKeyFile))
      ..add(DiagnosticsProperty('validDecryption', validDecryption));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DecryptionImpl &&
            (identical(other.publicKey, publicKey) ||
                other.publicKey == publicKey) &&
            (identical(other.privateKey, privateKey) ||
                other.privateKey == privateKey) &&
            (identical(other.symmetricKey, symmetricKey) ||
                other.symmetricKey == symmetricKey) &&
            (identical(other.fileToSend, fileToSend) ||
                other.fileToSend == fileToSend) &&
            (identical(other.teacherPublicKeyFile, teacherPublicKeyFile) ||
                other.teacherPublicKeyFile == teacherPublicKeyFile) &&
            (identical(other.fileDigest, fileDigest) ||
                other.fileDigest == fileDigest) &&
            (identical(other.fileSignature, fileSignature) ||
                other.fileSignature == fileSignature) &&
            (identical(other.fileEncryption, fileEncryption) ||
                other.fileEncryption == fileEncryption) &&
            (identical(other.symmetricKeyEncryption, symmetricKeyEncryption) ||
                other.symmetricKeyEncryption == symmetricKeyEncryption) &&
            (identical(other.teacherPrivateKeyFile, teacherPrivateKeyFile) ||
                other.teacherPrivateKeyFile == teacherPrivateKeyFile) &&
            (identical(other.selectingTeacherPrivateKeyFile,
                    selectingTeacherPrivateKeyFile) ||
                other.selectingTeacherPrivateKeyFile ==
                    selectingTeacherPrivateKeyFile) &&
            (identical(other.validDecryption, validDecryption) ||
                other.validDecryption == validDecryption));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      publicKey,
      privateKey,
      symmetricKey,
      fileToSend,
      teacherPublicKeyFile,
      fileDigest,
      fileSignature,
      fileEncryption,
      symmetricKeyEncryption,
      teacherPrivateKeyFile,
      selectingTeacherPrivateKeyFile,
      validDecryption);

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DecryptionImplCopyWith<_$DecryptionImpl> get copyWith =>
      __$$DecryptionImplCopyWithImpl<_$DecryptionImpl>(this, _$identity);
}

abstract class _Decryption implements Decryption {
  const factory _Decryption(
      {required final String publicKey,
      required final String privateKey,
      required final String symmetricKey,
      required final FileReader fileToSend,
      required final FileReader teacherPublicKeyFile,
      required final String fileDigest,
      required final String fileSignature,
      required final String fileEncryption,
      required final String symmetricKeyEncryption,
      final FileReader? teacherPrivateKeyFile,
      final bool selectingTeacherPrivateKeyFile,
      final bool validDecryption}) = _$DecryptionImpl;

  @override
  String get publicKey;
  @override
  String get privateKey;
  @override
  String get symmetricKey;
  @override
  FileReader get fileToSend;
  @override
  FileReader get teacherPublicKeyFile;
  @override
  String get fileDigest;
  @override
  String get fileSignature;
  @override
  String get fileEncryption;
  @override
  String get symmetricKeyEncryption;
  @override
  FileReader? get teacherPrivateKeyFile;
  @override
  bool get selectingTeacherPrivateKeyFile;
  @override
  bool get validDecryption;

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DecryptionImplCopyWith<_$DecryptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
