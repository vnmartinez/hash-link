// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'generate_key_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$NextStep {}

/// @nodoc
abstract class $NextStepCopyWith<$Res> {
  factory $NextStepCopyWith(NextStep value, $Res Function(NextStep) then) =
      _$NextStepCopyWithImpl<$Res, NextStep>;
}

/// @nodoc
class _$NextStepCopyWithImpl<$Res, $Val extends NextStep>
    implements $NextStepCopyWith<$Res> {
  _$NextStepCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NextStep
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$NextStepImplCopyWith<$Res> {
  factory _$$NextStepImplCopyWith(
          _$NextStepImpl value, $Res Function(_$NextStepImpl) then) =
      __$$NextStepImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NextStepImplCopyWithImpl<$Res>
    extends _$NextStepCopyWithImpl<$Res, _$NextStepImpl>
    implements _$$NextStepImplCopyWith<$Res> {
  __$$NextStepImplCopyWithImpl(
      _$NextStepImpl _value, $Res Function(_$NextStepImpl) _then)
      : super(_value, _then);

  /// Create a copy of NextStep
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$NextStepImpl with DiagnosticableTreeMixin implements _NextStep {
  const _$NextStepImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NextStep()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'NextStep'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NextStepImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _NextStep implements NextStep {
  const factory _NextStep() = _$NextStepImpl;
}

/// @nodoc
mixin _$PreviousStep {}

/// @nodoc
abstract class $PreviousStepCopyWith<$Res> {
  factory $PreviousStepCopyWith(
          PreviousStep value, $Res Function(PreviousStep) then) =
      _$PreviousStepCopyWithImpl<$Res, PreviousStep>;
}

/// @nodoc
class _$PreviousStepCopyWithImpl<$Res, $Val extends PreviousStep>
    implements $PreviousStepCopyWith<$Res> {
  _$PreviousStepCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PreviousStep
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$PreviousStepImplCopyWith<$Res> {
  factory _$$PreviousStepImplCopyWith(
          _$PreviousStepImpl value, $Res Function(_$PreviousStepImpl) then) =
      __$$PreviousStepImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PreviousStepImplCopyWithImpl<$Res>
    extends _$PreviousStepCopyWithImpl<$Res, _$PreviousStepImpl>
    implements _$$PreviousStepImplCopyWith<$Res> {
  __$$PreviousStepImplCopyWithImpl(
      _$PreviousStepImpl _value, $Res Function(_$PreviousStepImpl) _then)
      : super(_value, _then);

  /// Create a copy of PreviousStep
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PreviousStepImpl with DiagnosticableTreeMixin implements _PreviousStep {
  const _$PreviousStepImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PreviousStep()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'PreviousStep'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PreviousStepImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _PreviousStep implements PreviousStep {
  const factory _PreviousStep() = _$PreviousStepImpl;
}

/// @nodoc
mixin _$GenerateRSAKeyPair {}

/// @nodoc
abstract class $GenerateRSAKeyPairCopyWith<$Res> {
  factory $GenerateRSAKeyPairCopyWith(
          GenerateRSAKeyPair value, $Res Function(GenerateRSAKeyPair) then) =
      _$GenerateRSAKeyPairCopyWithImpl<$Res, GenerateRSAKeyPair>;
}

/// @nodoc
class _$GenerateRSAKeyPairCopyWithImpl<$Res, $Val extends GenerateRSAKeyPair>
    implements $GenerateRSAKeyPairCopyWith<$Res> {
  _$GenerateRSAKeyPairCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GenerateRSAKeyPair
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$GenerateRSAKeyPairImplCopyWith<$Res> {
  factory _$$GenerateRSAKeyPairImplCopyWith(_$GenerateRSAKeyPairImpl value,
          $Res Function(_$GenerateRSAKeyPairImpl) then) =
      __$$GenerateRSAKeyPairImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GenerateRSAKeyPairImplCopyWithImpl<$Res>
    extends _$GenerateRSAKeyPairCopyWithImpl<$Res, _$GenerateRSAKeyPairImpl>
    implements _$$GenerateRSAKeyPairImplCopyWith<$Res> {
  __$$GenerateRSAKeyPairImplCopyWithImpl(_$GenerateRSAKeyPairImpl _value,
      $Res Function(_$GenerateRSAKeyPairImpl) _then)
      : super(_value, _then);

  /// Create a copy of GenerateRSAKeyPair
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GenerateRSAKeyPairImpl
    with DiagnosticableTreeMixin
    implements _GenerateRSAKeyPair {
  const _$GenerateRSAKeyPairImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GenerateRSAKeyPair()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'GenerateRSAKeyPair'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GenerateRSAKeyPairImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _GenerateRSAKeyPair implements GenerateRSAKeyPair {
  const factory _GenerateRSAKeyPair() = _$GenerateRSAKeyPairImpl;
}

/// @nodoc
mixin _$GenerateAESSymmetricKey {}

/// @nodoc
abstract class $GenerateAESSymmetricKeyCopyWith<$Res> {
  factory $GenerateAESSymmetricKeyCopyWith(GenerateAESSymmetricKey value,
          $Res Function(GenerateAESSymmetricKey) then) =
      _$GenerateAESSymmetricKeyCopyWithImpl<$Res, GenerateAESSymmetricKey>;
}

/// @nodoc
class _$GenerateAESSymmetricKeyCopyWithImpl<$Res,
        $Val extends GenerateAESSymmetricKey>
    implements $GenerateAESSymmetricKeyCopyWith<$Res> {
  _$GenerateAESSymmetricKeyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GenerateAESSymmetricKey
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$GenerateAESSymmetricKeyImplCopyWith<$Res> {
  factory _$$GenerateAESSymmetricKeyImplCopyWith(
          _$GenerateAESSymmetricKeyImpl value,
          $Res Function(_$GenerateAESSymmetricKeyImpl) then) =
      __$$GenerateAESSymmetricKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GenerateAESSymmetricKeyImplCopyWithImpl<$Res>
    extends _$GenerateAESSymmetricKeyCopyWithImpl<$Res,
        _$GenerateAESSymmetricKeyImpl>
    implements _$$GenerateAESSymmetricKeyImplCopyWith<$Res> {
  __$$GenerateAESSymmetricKeyImplCopyWithImpl(
      _$GenerateAESSymmetricKeyImpl _value,
      $Res Function(_$GenerateAESSymmetricKeyImpl) _then)
      : super(_value, _then);

  /// Create a copy of GenerateAESSymmetricKey
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GenerateAESSymmetricKeyImpl
    with DiagnosticableTreeMixin
    implements _GenerateAESSymmetricKey {
  const _$GenerateAESSymmetricKeyImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GenerateAESSymmetricKey()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'GenerateAESSymmetricKey'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GenerateAESSymmetricKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _GenerateAESSymmetricKey implements GenerateAESSymmetricKey {
  const factory _GenerateAESSymmetricKey() = _$GenerateAESSymmetricKeyImpl;
}

/// @nodoc
mixin _$KeyGeneration {}

/// @nodoc
abstract class $KeyGenerationCopyWith<$Res> {
  factory $KeyGenerationCopyWith(
          KeyGeneration value, $Res Function(KeyGeneration) then) =
      _$KeyGenerationCopyWithImpl<$Res, KeyGeneration>;
}

/// @nodoc
class _$KeyGenerationCopyWithImpl<$Res, $Val extends KeyGeneration>
    implements $KeyGenerationCopyWith<$Res> {
  _$KeyGenerationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of KeyGeneration
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$KeyGenerationImplCopyWith<$Res> {
  factory _$$KeyGenerationImplCopyWith(
          _$KeyGenerationImpl value, $Res Function(_$KeyGenerationImpl) then) =
      __$$KeyGenerationImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$KeyGenerationImplCopyWithImpl<$Res>
    extends _$KeyGenerationCopyWithImpl<$Res, _$KeyGenerationImpl>
    implements _$$KeyGenerationImplCopyWith<$Res> {
  __$$KeyGenerationImplCopyWithImpl(
      _$KeyGenerationImpl _value, $Res Function(_$KeyGenerationImpl) _then)
      : super(_value, _then);

  /// Create a copy of KeyGeneration
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$KeyGenerationImpl
    with DiagnosticableTreeMixin
    implements _KeyGeneration {
  const _$KeyGenerationImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'KeyGeneration()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'KeyGeneration'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$KeyGenerationImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _KeyGeneration implements KeyGeneration {
  const factory _KeyGeneration() = _$KeyGenerationImpl;
}

/// @nodoc
mixin _$Preparation {}

/// @nodoc
abstract class $PreparationCopyWith<$Res> {
  factory $PreparationCopyWith(
          Preparation value, $Res Function(Preparation) then) =
      _$PreparationCopyWithImpl<$Res, Preparation>;
}

/// @nodoc
class _$PreparationCopyWithImpl<$Res, $Val extends Preparation>
    implements $PreparationCopyWith<$Res> {
  _$PreparationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Preparation
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$PreparationImplCopyWith<$Res> {
  factory _$$PreparationImplCopyWith(
          _$PreparationImpl value, $Res Function(_$PreparationImpl) then) =
      __$$PreparationImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PreparationImplCopyWithImpl<$Res>
    extends _$PreparationCopyWithImpl<$Res, _$PreparationImpl>
    implements _$$PreparationImplCopyWith<$Res> {
  __$$PreparationImplCopyWithImpl(
      _$PreparationImpl _value, $Res Function(_$PreparationImpl) _then)
      : super(_value, _then);

  /// Create a copy of Preparation
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PreparationImpl with DiagnosticableTreeMixin implements _Preparation {
  const _$PreparationImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Preparation()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'Preparation'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PreparationImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _Preparation implements Preparation {
  const factory _Preparation() = _$PreparationImpl;
}

/// @nodoc
mixin _$Signature {}

/// @nodoc
abstract class $SignatureCopyWith<$Res> {
  factory $SignatureCopyWith(Signature value, $Res Function(Signature) then) =
      _$SignatureCopyWithImpl<$Res, Signature>;
}

/// @nodoc
class _$SignatureCopyWithImpl<$Res, $Val extends Signature>
    implements $SignatureCopyWith<$Res> {
  _$SignatureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Signature
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SignatureImplCopyWith<$Res> {
  factory _$$SignatureImplCopyWith(
          _$SignatureImpl value, $Res Function(_$SignatureImpl) then) =
      __$$SignatureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignatureImplCopyWithImpl<$Res>
    extends _$SignatureCopyWithImpl<$Res, _$SignatureImpl>
    implements _$$SignatureImplCopyWith<$Res> {
  __$$SignatureImplCopyWithImpl(
      _$SignatureImpl _value, $Res Function(_$SignatureImpl) _then)
      : super(_value, _then);

  /// Create a copy of Signature
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SignatureImpl with DiagnosticableTreeMixin implements _Signature {
  const _$SignatureImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Signature()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'Signature'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SignatureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _Signature implements Signature {
  const factory _Signature() = _$SignatureImpl;
}

/// @nodoc
mixin _$Protection {}

/// @nodoc
abstract class $ProtectionCopyWith<$Res> {
  factory $ProtectionCopyWith(
          Protection value, $Res Function(Protection) then) =
      _$ProtectionCopyWithImpl<$Res, Protection>;
}

/// @nodoc
class _$ProtectionCopyWithImpl<$Res, $Val extends Protection>
    implements $ProtectionCopyWith<$Res> {
  _$ProtectionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Protection
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ProtectionImplCopyWith<$Res> {
  factory _$$ProtectionImplCopyWith(
          _$ProtectionImpl value, $Res Function(_$ProtectionImpl) then) =
      __$$ProtectionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ProtectionImplCopyWithImpl<$Res>
    extends _$ProtectionCopyWithImpl<$Res, _$ProtectionImpl>
    implements _$$ProtectionImplCopyWith<$Res> {
  __$$ProtectionImplCopyWithImpl(
      _$ProtectionImpl _value, $Res Function(_$ProtectionImpl) _then)
      : super(_value, _then);

  /// Create a copy of Protection
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ProtectionImpl with DiagnosticableTreeMixin implements _Protection {
  const _$ProtectionImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Protection()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'Protection'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ProtectionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _Protection implements Protection {
  const factory _Protection() = _$ProtectionImpl;
}

/// @nodoc
mixin _$Shipping {}

/// @nodoc
abstract class $ShippingCopyWith<$Res> {
  factory $ShippingCopyWith(Shipping value, $Res Function(Shipping) then) =
      _$ShippingCopyWithImpl<$Res, Shipping>;
}

/// @nodoc
class _$ShippingCopyWithImpl<$Res, $Val extends Shipping>
    implements $ShippingCopyWith<$Res> {
  _$ShippingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Shipping
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ShippingImplCopyWith<$Res> {
  factory _$$ShippingImplCopyWith(
          _$ShippingImpl value, $Res Function(_$ShippingImpl) then) =
      __$$ShippingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ShippingImplCopyWithImpl<$Res>
    extends _$ShippingCopyWithImpl<$Res, _$ShippingImpl>
    implements _$$ShippingImplCopyWith<$Res> {
  __$$ShippingImplCopyWithImpl(
      _$ShippingImpl _value, $Res Function(_$ShippingImpl) _then)
      : super(_value, _then);

  /// Create a copy of Shipping
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ShippingImpl with DiagnosticableTreeMixin implements _Shipping {
  const _$ShippingImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Shipping()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'Shipping'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ShippingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _Shipping implements Shipping {
  const factory _Shipping() = _$ShippingImpl;
}

/// @nodoc
mixin _$Decryption {}

/// @nodoc
abstract class $DecryptionCopyWith<$Res> {
  factory $DecryptionCopyWith(
          Decryption value, $Res Function(Decryption) then) =
      _$DecryptionCopyWithImpl<$Res, Decryption>;
}

/// @nodoc
class _$DecryptionCopyWithImpl<$Res, $Val extends Decryption>
    implements $DecryptionCopyWith<$Res> {
  _$DecryptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$DecryptionImplCopyWith<$Res> {
  factory _$$DecryptionImplCopyWith(
          _$DecryptionImpl value, $Res Function(_$DecryptionImpl) then) =
      __$$DecryptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DecryptionImplCopyWithImpl<$Res>
    extends _$DecryptionCopyWithImpl<$Res, _$DecryptionImpl>
    implements _$$DecryptionImplCopyWith<$Res> {
  __$$DecryptionImplCopyWithImpl(
      _$DecryptionImpl _value, $Res Function(_$DecryptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of Decryption
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$DecryptionImpl with DiagnosticableTreeMixin implements _Decryption {
  const _$DecryptionImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Decryption()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'Decryption'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DecryptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _Decryption implements Decryption {
  const factory _Decryption() = _$DecryptionImpl;
}
