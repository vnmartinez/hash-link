// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'decrypt_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ResetDecrypt {}

/// @nodoc
abstract class $ResetDecryptCopyWith<$Res> {
  factory $ResetDecryptCopyWith(
          ResetDecrypt value, $Res Function(ResetDecrypt) then) =
      _$ResetDecryptCopyWithImpl<$Res, ResetDecrypt>;
}

/// @nodoc
class _$ResetDecryptCopyWithImpl<$Res, $Val extends ResetDecrypt>
    implements $ResetDecryptCopyWith<$Res> {
  _$ResetDecryptCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ResetDecrypt
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ResetDecryptImplCopyWith<$Res> {
  factory _$$ResetDecryptImplCopyWith(
          _$ResetDecryptImpl value, $Res Function(_$ResetDecryptImpl) then) =
      __$$ResetDecryptImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ResetDecryptImplCopyWithImpl<$Res>
    extends _$ResetDecryptCopyWithImpl<$Res, _$ResetDecryptImpl>
    implements _$$ResetDecryptImplCopyWith<$Res> {
  __$$ResetDecryptImplCopyWithImpl(
      _$ResetDecryptImpl _value, $Res Function(_$ResetDecryptImpl) _then)
      : super(_value, _then);

  /// Create a copy of ResetDecrypt
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ResetDecryptImpl implements _ResetDecrypt {
  const _$ResetDecryptImpl();

  @override
  String toString() {
    return 'ResetDecrypt()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ResetDecryptImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _ResetDecrypt implements ResetDecrypt {
  const factory _ResetDecrypt() = _$ResetDecryptImpl;
}

/// @nodoc
mixin _$SelectPackage {}

/// @nodoc
abstract class $SelectPackageCopyWith<$Res> {
  factory $SelectPackageCopyWith(
          SelectPackage value, $Res Function(SelectPackage) then) =
      _$SelectPackageCopyWithImpl<$Res, SelectPackage>;
}

/// @nodoc
class _$SelectPackageCopyWithImpl<$Res, $Val extends SelectPackage>
    implements $SelectPackageCopyWith<$Res> {
  _$SelectPackageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SelectPackage
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SelectPackageImplCopyWith<$Res> {
  factory _$$SelectPackageImplCopyWith(
          _$SelectPackageImpl value, $Res Function(_$SelectPackageImpl) then) =
      __$$SelectPackageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectPackageImplCopyWithImpl<$Res>
    extends _$SelectPackageCopyWithImpl<$Res, _$SelectPackageImpl>
    implements _$$SelectPackageImplCopyWith<$Res> {
  __$$SelectPackageImplCopyWithImpl(
      _$SelectPackageImpl _value, $Res Function(_$SelectPackageImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectPackage
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SelectPackageImpl implements _SelectPackage {
  const _$SelectPackageImpl();

  @override
  String toString() {
    return 'SelectPackage()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SelectPackageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _SelectPackage implements SelectPackage {
  const factory _SelectPackage() = _$SelectPackageImpl;
}

/// @nodoc
mixin _$SelectPrivateKey {}

/// @nodoc
abstract class $SelectPrivateKeyCopyWith<$Res> {
  factory $SelectPrivateKeyCopyWith(
          SelectPrivateKey value, $Res Function(SelectPrivateKey) then) =
      _$SelectPrivateKeyCopyWithImpl<$Res, SelectPrivateKey>;
}

/// @nodoc
class _$SelectPrivateKeyCopyWithImpl<$Res, $Val extends SelectPrivateKey>
    implements $SelectPrivateKeyCopyWith<$Res> {
  _$SelectPrivateKeyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SelectPrivateKey
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SelectPrivateKeyImplCopyWith<$Res> {
  factory _$$SelectPrivateKeyImplCopyWith(_$SelectPrivateKeyImpl value,
          $Res Function(_$SelectPrivateKeyImpl) then) =
      __$$SelectPrivateKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectPrivateKeyImplCopyWithImpl<$Res>
    extends _$SelectPrivateKeyCopyWithImpl<$Res, _$SelectPrivateKeyImpl>
    implements _$$SelectPrivateKeyImplCopyWith<$Res> {
  __$$SelectPrivateKeyImplCopyWithImpl(_$SelectPrivateKeyImpl _value,
      $Res Function(_$SelectPrivateKeyImpl) _then)
      : super(_value, _then);

  /// Create a copy of SelectPrivateKey
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SelectPrivateKeyImpl implements _SelectPrivateKey {
  const _$SelectPrivateKeyImpl();

  @override
  String toString() {
    return 'SelectPrivateKey()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SelectPrivateKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _SelectPrivateKey implements SelectPrivateKey {
  const factory _SelectPrivateKey() = _$SelectPrivateKeyImpl;
}

/// @nodoc
mixin _$DecryptData {}

/// @nodoc
abstract class $DecryptDataCopyWith<$Res> {
  factory $DecryptDataCopyWith(
          DecryptData value, $Res Function(DecryptData) then) =
      _$DecryptDataCopyWithImpl<$Res, DecryptData>;
}

/// @nodoc
class _$DecryptDataCopyWithImpl<$Res, $Val extends DecryptData>
    implements $DecryptDataCopyWith<$Res> {
  _$DecryptDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DecryptData
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$DecryptDataImplCopyWith<$Res> {
  factory _$$DecryptDataImplCopyWith(
          _$DecryptDataImpl value, $Res Function(_$DecryptDataImpl) then) =
      __$$DecryptDataImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DecryptDataImplCopyWithImpl<$Res>
    extends _$DecryptDataCopyWithImpl<$Res, _$DecryptDataImpl>
    implements _$$DecryptDataImplCopyWith<$Res> {
  __$$DecryptDataImplCopyWithImpl(
      _$DecryptDataImpl _value, $Res Function(_$DecryptDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of DecryptData
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$DecryptDataImpl implements _DecryptData {
  const _$DecryptDataImpl();

  @override
  String toString() {
    return 'DecryptData()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DecryptDataImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _DecryptData implements DecryptData {
  const factory _DecryptData() = _$DecryptDataImpl;
}

/// @nodoc
mixin _$DecryptState {
  Uint8List? get dataEncrypted => throw _privateConstructorUsedError;
  String? get dataEncryptedError => throw _privateConstructorUsedError;
  Uint8List? get aesKey => throw _privateConstructorUsedError;
  String? get aesKeyError => throw _privateConstructorUsedError;
  Uint8List? get signature => throw _privateConstructorUsedError;
  String? get signatureError => throw _privateConstructorUsedError;
  Uint8List? get publicKey => throw _privateConstructorUsedError;
  String? get publicKeyError => throw _privateConstructorUsedError;
  Uint8List? get privateKey => throw _privateConstructorUsedError;
  String? get privateKeyError => throw _privateConstructorUsedError;
  Uint8List? get decryptedFile => throw _privateConstructorUsedError;
  String? get decryptionError => throw _privateConstructorUsedError;
  bool get selectingPackage => throw _privateConstructorUsedError;
  bool get selectingPrivateKey => throw _privateConstructorUsedError;
  bool get isSignatureValid => throw _privateConstructorUsedError;

  /// Create a copy of DecryptState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DecryptStateCopyWith<DecryptState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DecryptStateCopyWith<$Res> {
  factory $DecryptStateCopyWith(
          DecryptState value, $Res Function(DecryptState) then) =
      _$DecryptStateCopyWithImpl<$Res, DecryptState>;
  @useResult
  $Res call(
      {Uint8List? dataEncrypted,
      String? dataEncryptedError,
      Uint8List? aesKey,
      String? aesKeyError,
      Uint8List? signature,
      String? signatureError,
      Uint8List? publicKey,
      String? publicKeyError,
      Uint8List? privateKey,
      String? privateKeyError,
      Uint8List? decryptedFile,
      String? decryptionError,
      bool selectingPackage,
      bool selectingPrivateKey,
      bool isSignatureValid});
}

/// @nodoc
class _$DecryptStateCopyWithImpl<$Res, $Val extends DecryptState>
    implements $DecryptStateCopyWith<$Res> {
  _$DecryptStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DecryptState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dataEncrypted = freezed,
    Object? dataEncryptedError = freezed,
    Object? aesKey = freezed,
    Object? aesKeyError = freezed,
    Object? signature = freezed,
    Object? signatureError = freezed,
    Object? publicKey = freezed,
    Object? publicKeyError = freezed,
    Object? privateKey = freezed,
    Object? privateKeyError = freezed,
    Object? decryptedFile = freezed,
    Object? decryptionError = freezed,
    Object? selectingPackage = null,
    Object? selectingPrivateKey = null,
    Object? isSignatureValid = null,
  }) {
    return _then(_value.copyWith(
      dataEncrypted: freezed == dataEncrypted
          ? _value.dataEncrypted
          : dataEncrypted // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      dataEncryptedError: freezed == dataEncryptedError
          ? _value.dataEncryptedError
          : dataEncryptedError // ignore: cast_nullable_to_non_nullable
              as String?,
      aesKey: freezed == aesKey
          ? _value.aesKey
          : aesKey // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      aesKeyError: freezed == aesKeyError
          ? _value.aesKeyError
          : aesKeyError // ignore: cast_nullable_to_non_nullable
              as String?,
      signature: freezed == signature
          ? _value.signature
          : signature // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      signatureError: freezed == signatureError
          ? _value.signatureError
          : signatureError // ignore: cast_nullable_to_non_nullable
              as String?,
      publicKey: freezed == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      publicKeyError: freezed == publicKeyError
          ? _value.publicKeyError
          : publicKeyError // ignore: cast_nullable_to_non_nullable
              as String?,
      privateKey: freezed == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      privateKeyError: freezed == privateKeyError
          ? _value.privateKeyError
          : privateKeyError // ignore: cast_nullable_to_non_nullable
              as String?,
      decryptedFile: freezed == decryptedFile
          ? _value.decryptedFile
          : decryptedFile // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      decryptionError: freezed == decryptionError
          ? _value.decryptionError
          : decryptionError // ignore: cast_nullable_to_non_nullable
              as String?,
      selectingPackage: null == selectingPackage
          ? _value.selectingPackage
          : selectingPackage // ignore: cast_nullable_to_non_nullable
              as bool,
      selectingPrivateKey: null == selectingPrivateKey
          ? _value.selectingPrivateKey
          : selectingPrivateKey // ignore: cast_nullable_to_non_nullable
              as bool,
      isSignatureValid: null == isSignatureValid
          ? _value.isSignatureValid
          : isSignatureValid // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DecryptStateImplCopyWith<$Res>
    implements $DecryptStateCopyWith<$Res> {
  factory _$$DecryptStateImplCopyWith(
          _$DecryptStateImpl value, $Res Function(_$DecryptStateImpl) then) =
      __$$DecryptStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Uint8List? dataEncrypted,
      String? dataEncryptedError,
      Uint8List? aesKey,
      String? aesKeyError,
      Uint8List? signature,
      String? signatureError,
      Uint8List? publicKey,
      String? publicKeyError,
      Uint8List? privateKey,
      String? privateKeyError,
      Uint8List? decryptedFile,
      String? decryptionError,
      bool selectingPackage,
      bool selectingPrivateKey,
      bool isSignatureValid});
}

/// @nodoc
class __$$DecryptStateImplCopyWithImpl<$Res>
    extends _$DecryptStateCopyWithImpl<$Res, _$DecryptStateImpl>
    implements _$$DecryptStateImplCopyWith<$Res> {
  __$$DecryptStateImplCopyWithImpl(
      _$DecryptStateImpl _value, $Res Function(_$DecryptStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of DecryptState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dataEncrypted = freezed,
    Object? dataEncryptedError = freezed,
    Object? aesKey = freezed,
    Object? aesKeyError = freezed,
    Object? signature = freezed,
    Object? signatureError = freezed,
    Object? publicKey = freezed,
    Object? publicKeyError = freezed,
    Object? privateKey = freezed,
    Object? privateKeyError = freezed,
    Object? decryptedFile = freezed,
    Object? decryptionError = freezed,
    Object? selectingPackage = null,
    Object? selectingPrivateKey = null,
    Object? isSignatureValid = null,
  }) {
    return _then(_$DecryptStateImpl(
      dataEncrypted: freezed == dataEncrypted
          ? _value.dataEncrypted
          : dataEncrypted // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      dataEncryptedError: freezed == dataEncryptedError
          ? _value.dataEncryptedError
          : dataEncryptedError // ignore: cast_nullable_to_non_nullable
              as String?,
      aesKey: freezed == aesKey
          ? _value.aesKey
          : aesKey // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      aesKeyError: freezed == aesKeyError
          ? _value.aesKeyError
          : aesKeyError // ignore: cast_nullable_to_non_nullable
              as String?,
      signature: freezed == signature
          ? _value.signature
          : signature // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      signatureError: freezed == signatureError
          ? _value.signatureError
          : signatureError // ignore: cast_nullable_to_non_nullable
              as String?,
      publicKey: freezed == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      publicKeyError: freezed == publicKeyError
          ? _value.publicKeyError
          : publicKeyError // ignore: cast_nullable_to_non_nullable
              as String?,
      privateKey: freezed == privateKey
          ? _value.privateKey
          : privateKey // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      privateKeyError: freezed == privateKeyError
          ? _value.privateKeyError
          : privateKeyError // ignore: cast_nullable_to_non_nullable
              as String?,
      decryptedFile: freezed == decryptedFile
          ? _value.decryptedFile
          : decryptedFile // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      decryptionError: freezed == decryptionError
          ? _value.decryptionError
          : decryptionError // ignore: cast_nullable_to_non_nullable
              as String?,
      selectingPackage: null == selectingPackage
          ? _value.selectingPackage
          : selectingPackage // ignore: cast_nullable_to_non_nullable
              as bool,
      selectingPrivateKey: null == selectingPrivateKey
          ? _value.selectingPrivateKey
          : selectingPrivateKey // ignore: cast_nullable_to_non_nullable
              as bool,
      isSignatureValid: null == isSignatureValid
          ? _value.isSignatureValid
          : isSignatureValid // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$DecryptStateImpl implements _DecryptState {
  const _$DecryptStateImpl(
      {this.dataEncrypted,
      this.dataEncryptedError,
      this.aesKey,
      this.aesKeyError,
      this.signature,
      this.signatureError,
      this.publicKey,
      this.publicKeyError,
      this.privateKey,
      this.privateKeyError,
      this.decryptedFile,
      this.decryptionError,
      this.selectingPackage = false,
      this.selectingPrivateKey = false,
      this.isSignatureValid = false});

  @override
  final Uint8List? dataEncrypted;
  @override
  final String? dataEncryptedError;
  @override
  final Uint8List? aesKey;
  @override
  final String? aesKeyError;
  @override
  final Uint8List? signature;
  @override
  final String? signatureError;
  @override
  final Uint8List? publicKey;
  @override
  final String? publicKeyError;
  @override
  final Uint8List? privateKey;
  @override
  final String? privateKeyError;
  @override
  final Uint8List? decryptedFile;
  @override
  final String? decryptionError;
  @override
  @JsonKey()
  final bool selectingPackage;
  @override
  @JsonKey()
  final bool selectingPrivateKey;
  @override
  @JsonKey()
  final bool isSignatureValid;

  @override
  String toString() {
    return 'DecryptState(dataEncrypted: $dataEncrypted, dataEncryptedError: $dataEncryptedError, aesKey: $aesKey, aesKeyError: $aesKeyError, signature: $signature, signatureError: $signatureError, publicKey: $publicKey, publicKeyError: $publicKeyError, privateKey: $privateKey, privateKeyError: $privateKeyError, decryptedFile: $decryptedFile, decryptionError: $decryptionError, selectingPackage: $selectingPackage, selectingPrivateKey: $selectingPrivateKey, isSignatureValid: $isSignatureValid)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DecryptStateImpl &&
            const DeepCollectionEquality()
                .equals(other.dataEncrypted, dataEncrypted) &&
            (identical(other.dataEncryptedError, dataEncryptedError) ||
                other.dataEncryptedError == dataEncryptedError) &&
            const DeepCollectionEquality().equals(other.aesKey, aesKey) &&
            (identical(other.aesKeyError, aesKeyError) ||
                other.aesKeyError == aesKeyError) &&
            const DeepCollectionEquality().equals(other.signature, signature) &&
            (identical(other.signatureError, signatureError) ||
                other.signatureError == signatureError) &&
            const DeepCollectionEquality().equals(other.publicKey, publicKey) &&
            (identical(other.publicKeyError, publicKeyError) ||
                other.publicKeyError == publicKeyError) &&
            const DeepCollectionEquality()
                .equals(other.privateKey, privateKey) &&
            (identical(other.privateKeyError, privateKeyError) ||
                other.privateKeyError == privateKeyError) &&
            const DeepCollectionEquality()
                .equals(other.decryptedFile, decryptedFile) &&
            (identical(other.decryptionError, decryptionError) ||
                other.decryptionError == decryptionError) &&
            (identical(other.selectingPackage, selectingPackage) ||
                other.selectingPackage == selectingPackage) &&
            (identical(other.selectingPrivateKey, selectingPrivateKey) ||
                other.selectingPrivateKey == selectingPrivateKey) &&
            (identical(other.isSignatureValid, isSignatureValid) ||
                other.isSignatureValid == isSignatureValid));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(dataEncrypted),
      dataEncryptedError,
      const DeepCollectionEquality().hash(aesKey),
      aesKeyError,
      const DeepCollectionEquality().hash(signature),
      signatureError,
      const DeepCollectionEquality().hash(publicKey),
      publicKeyError,
      const DeepCollectionEquality().hash(privateKey),
      privateKeyError,
      const DeepCollectionEquality().hash(decryptedFile),
      decryptionError,
      selectingPackage,
      selectingPrivateKey,
      isSignatureValid);

  /// Create a copy of DecryptState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DecryptStateImplCopyWith<_$DecryptStateImpl> get copyWith =>
      __$$DecryptStateImplCopyWithImpl<_$DecryptStateImpl>(this, _$identity);
}

abstract class _DecryptState implements DecryptState {
  const factory _DecryptState(
      {final Uint8List? dataEncrypted,
      final String? dataEncryptedError,
      final Uint8List? aesKey,
      final String? aesKeyError,
      final Uint8List? signature,
      final String? signatureError,
      final Uint8List? publicKey,
      final String? publicKeyError,
      final Uint8List? privateKey,
      final String? privateKeyError,
      final Uint8List? decryptedFile,
      final String? decryptionError,
      final bool selectingPackage,
      final bool selectingPrivateKey,
      final bool isSignatureValid}) = _$DecryptStateImpl;

  @override
  Uint8List? get dataEncrypted;
  @override
  String? get dataEncryptedError;
  @override
  Uint8List? get aesKey;
  @override
  String? get aesKeyError;
  @override
  Uint8List? get signature;
  @override
  String? get signatureError;
  @override
  Uint8List? get publicKey;
  @override
  String? get publicKeyError;
  @override
  Uint8List? get privateKey;
  @override
  String? get privateKeyError;
  @override
  Uint8List? get decryptedFile;
  @override
  String? get decryptionError;
  @override
  bool get selectingPackage;
  @override
  bool get selectingPrivateKey;
  @override
  bool get isSignatureValid;

  /// Create a copy of DecryptState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DecryptStateImplCopyWith<_$DecryptStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
